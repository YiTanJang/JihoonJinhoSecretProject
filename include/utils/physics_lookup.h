#pragma once
#include <vector>
#include <algorithm>
#include <cmath>

namespace PhysicsLookup {
    struct DataPoint {
        double bad_ar;
        double temp;
    };

    // Data from physics_logs_20260130_183514
    // Sorted by Bad AR descending
    static const std::vector<DataPoint> lookup_table = {
        {0.8088, 307.06}, {0.8021, 296.38}, {0.7958, 285.70}, {0.7908, 275.75},
        {0.7841, 265.79}, {0.7746, 256.21}, {0.7692, 247.06}, {0.7619, 238.16},
        {0.7561, 229.61}, {0.7467, 221.48}, {0.7406, 213.49}, {0.7325, 205.78},
        {0.7237, 198.46}, {0.7160, 191.33}, {0.7074, 184.45}, {0.6993, 177.85},
        {0.6899, 171.51}, {0.6816, 165.33}, {0.6713, 159.38}, {0.6642, 153.70},
        {0.6560, 148.15}, {0.6462, 142.85}, {0.6363, 137.73}, {0.6282, 132.79},
        {0.6179, 128.01}, {0.6078, 123.43}, {0.5971, 119.02}, {0.5893, 114.74},
        {0.5769, 110.62}, {0.5684, 106.67}, {0.5591, 102.83}, {0.5474, 99.12},
        {0.5368, 95.58},  {0.5264, 92.17},  {0.5163, 88.85},  {0.5053, 85.65},
        {0.4956, 82.60},  {0.4837, 79.63},  {0.4728, 76.77},  {0.4617, 74.02},
        {0.4547, 71.38},  {0.4423, 68.81},  {0.4317, 66.33},  {0.4219, 63.97},
        {0.4116, 61.67},  {0.4006, 59.45},  {0.3920, 57.32},  {0.3801, 55.27},
        {0.3720, 53.27},  {0.3621, 51.37},  {0.3519, 49.54},  {0.3429, 47.75},
        {0.3331, 46.04},  {0.3252, 44.39},  {0.3157, 42.80},  {0.3077, 41.26},
        {0.2987, 39.78},  {0.2904, 38.36},  {0.2818, 36.98},  {0.2744, 35.65},
        {0.2673, 34.38},  {0.2596, 33.14},  {0.2514, 31.95},  {0.2440, 30.81},
        {0.2376, 29.70},  {0.2295, 28.63},  {0.2239, 27.61},  {0.2176, 26.62},
        {0.2119, 25.67},  {0.2056, 24.74},  {0.1983, 23.86},  {0.1944, 23.00},
        {0.1884, 22.17},  {0.1832, 21.38},  {0.1783, 20.61},  {0.1740, 19.87},
        {0.1679, 19.16},  {0.1637, 18.47},  {0.1592, 17.81},  {0.1546, 17.17},
        {0.1503, 16.56},  {0.1461, 15.97},  {0.1427, 15.39},  {0.1382, 14.84},
        {0.1345, 14.31},  {0.1317, 13.79},  {0.1290, 13.30},  {0.1259, 12.82},
        {0.1219, 12.36},  {0.1181, 11.92},  {0.1154, 11.49},  {0.1130, 11.08},
        {0.1095, 10.68},  {0.1059, 10.30},  {0.1033, 9.93},   {0.1019, 9.57},
        {0.0995, 9.23},   {0.0968, 8.90},   {0.0959, 8.58},   {0.0927, 8.27},
        {0.0912, 7.97},   {0.0892, 7.69},   {0.0875, 7.41},   {0.0850, 7.15},
        {0.0830, 6.89},   {0.0816, 6.64},   {0.0799, 6.40},   {0.0771, 6.17},
        {0.0758, 5.95},   {0.0749, 5.74},   {0.0728, 5.53},   {0.0710, 5.34},
        {0.0697, 5.14},   {0.0687, 4.96},   {0.0670, 4.78},   {0.0660, 4.61},
        {0.0654, 4.44},   {0.0639, 4.28},   {0.0622, 4.13},   {0.0595, 3.98},
        {0.0599, 3.84},   {0.0582, 3.70},   {0.0573, 3.57},   {0.0568, 3.44},
        {0.0533, 3.32},   {0.0531, 3.20},   {0.0520, 3.09},   {0.0514, 2.97},
        {0.0517, 2.87},   {0.0482, 2.76},   {0.0494, 2.67},   {0.0458, 2.57},
        {0.0455, 2.48},   {0.0460, 2.39},   {0.0427, 2.30},   {0.0433, 2.22},
        {0.0414, 2.14},   {0.0398, 2.06},   {0.0403, 1.99},   {0.0383, 1.92},
        {0.0374, 1.85},   {0.0365, 1.78},   {0.0361, 1.72},   {0.0353, 1.66},
        {0.0342, 1.60},   {0.0348, 1.54},   {0.0323, 1.49},   {0.0316, 1.43},
        {0.0304, 1.38},   {0.0281, 1.33},   {0.0271, 1.28},   {0.0270, 1.24},
        {0.0253, 1.19},   {0.0249, 1.15},   {0.0231, 1.11},   {0.0225, 1.07},
        {0.0230, 1.03},   {0.0227, 0.99},   {0.0227, 0.96},   {0.0207, 0.92},
        {0.0192, 0.89},   {0.0188, 0.86},   {0.0182, 0.83},   {0.0182, 0.80},
        {0.0164, 0.77},   {0.0163, 0.74},   {0.0157, 0.72},   {0.0143, 0.69},
        {0.0144, 0.67},   {0.0145, 0.64},   {0.0135, 0.62},   {0.0138, 0.60},
        {0.0122, 0.57},   {0.0123, 0.55},   {0.0130, 0.53},   {0.0124, 0.52},
        {0.0124, 0.50},   {0.0121, 0.48},   {0.0123, 0.46}
    };

    inline double get_temp_for_bad_ar(double target_bad_ar) {
        // Handle out of bounds
        if (target_bad_ar >= lookup_table.front().bad_ar) return lookup_table.front().temp;
        if (target_bad_ar <= lookup_table.back().bad_ar) return lookup_table.back().temp;

        // Linear Interpolation
        for (size_t i = 0; i < lookup_table.size() - 1; ++i) {
            const auto& p1 = lookup_table[i];
            const auto& p2 = lookup_table[i + 1];

            // Because table is sorted descending by Bad AR
            if (target_bad_ar <= p1.bad_ar && target_bad_ar > p2.bad_ar) {
                double t = (target_bad_ar - p2.bad_ar) / (p1.bad_ar - p2.bad_ar);
                return p2.temp + t * (p1.temp - p2.temp);
            }
        }
        return lookup_table.back().temp;
    }
}
