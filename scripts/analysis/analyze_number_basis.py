#!/usr/bin/env python3
"""
Analyze Number Basis (Dependencies)

This script analyzes the "span" or dependencies between numbers.
It treats a number (string of digits) as a 1D board and finds all other numbers
(up to length 4) that can be generated by walking along adjacent digits (index +/- 1).

It attempts to find a "basis set" of numbers such that all other numbers
(1-1000 and 0000-9999) are covered by the span of this basis set.

Original logic from a.py.
"""

def get_span(number_str, max_len=4):
    """
    Returns a set of all strings (numbers) that can be formed by traversing
    the digits of number_str (treated as a 1D board).
    
    Traversal allows moving to adjacent indices (i-1, i+1).
    
    Args:
        number_str (str): The number to analyze.
        max_len (int): Maximum length of generated strings.
    
    Returns:
        set: A set of strings reachable from number_str.
    """
    n = len(number_str)
    # queue: list of tuples (current_string, current_index)
    # Initialize with each digit starting at its position
    queue = [(number_str[i], i) for i in range(n)]
    
    # We iterate through the list while appending to it (BFS-like)
    # Note: 'queue' grows.
    results = set()
    
    # Using an index to iterate to allow appending
    idx = 0
    while idx < len(queue):
        s, i = queue[idx]
        idx += 1
        
        # Add to results (implicitly done by the return set comprehension in original,
        # but here we collect explicitly or just return the set of strings from queue)
        # The original code returned {i for i,_ in l}, which implies 's' (the string).
        
        # Explore neighbors
        for neighbor_idx in (i - 1, i + 1):
            if 0 <= neighbor_idx < n:
                new_s = s + number_str[neighbor_idx]
                if len(new_s) <= max_len: # Changed < 5 to <= max_len for clarity (max_len=4)
                    queue.append((new_s, neighbor_idx))
                    
    return {item[0] for item in queue}

def main():
    covered_set = set() # 'ps' in original
    basis_set = set()   # 'ss' in original

    # Phase 1: Numbers 1 to 999
    print("Analyzing 1-999...")
    for i in range(1, 1000):
        s = str(i)
        if s not in covered_set:
            span_s = get_span(s)
            covered_set |= span_s
            
            # If the new number 's' covers things that were previously in the basis,
            # we might remove them? (Original logic: ss -= span(s))
            # This implies 's' is a "better" generator than whatever was there before.
            basis_set -= span_s
            basis_set.add(s)

    # Phase 2: Numbers 0000 to 9999
    print("Analyzing 0000-9999...")
    for i in range(0, 10000):
        s = f'{i:04d}'
        if s not in covered_set:
            span_s = get_span(s)
            covered_set |= span_s
            basis_set -= span_s
            basis_set.add(s)

    print(f"Basis size: {len(basis_set)}")
    
    # Verification / Analysis of the basis
    # The original code printed: if 1<=len(ssc&span(i)): print(...)
    # This checks which basis elements cover other basis elements (or themselves).
    # Since a basis element always covers itself, the intersection size is at least 1.
    # We will print the basis elements and maybe what they cover within the basis.
    
    basis_set_static = list(basis_set)
    basis_set_static.sort()
    
    basis_3d = []
    basis_4d = []
    
    for b in basis_set_static:
        if len(b) == 3:
            basis_3d.append(int(b))
        elif len(b) == 4:
            basis_4d.append(int(b))
            
    print(f"Writing to include/basis_set.h...")
    with open('include/basis_set.h', 'w') as f:
        f.write("#pragma once\n")
        f.write("#include <vector>\n\n")
        f.write("namespace BasisSet {\n")
        f.write(f"    const int BASIS_3D_SIZE = {len(basis_3d)};\n")
        f.write(f"    const int BASIS_4D_SIZE = {len(basis_4d)};\n\n")
        f.write("    const int BASIS_3D[] = {")
        f.write(", ".join(map(str, basis_3d)))
        f.write("};\n\n")
        f.write("    const int BASIS_4D[] = {")
        f.write(", ".join(map(str, basis_4d)))
        f.write("};\n")
        f.write("}\n")

    print("\nBasis elements and their self-coverage (sanity check):")
    for b in basis_set_static:
        span_b = get_span(b)
        intersection = basis_set.intersection(span_b)
        # Original condition was 1 <= len. This is always true for itself.
        # Maybe the interest is if it covers *multiple* basis elements?
        if len(intersection) >= 1: 
            print(f"Basis: {b} -> Covers in basis: {intersection}")

if __name__ == "__main__":
    main()
